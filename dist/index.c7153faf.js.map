{"mappings":"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","sources":["src/clip.ts","src/puzzle-piece.ts","src/shape.ts","src/slots.ts","src/game.ts","src/index.ts"],"sourcesContent":["import Shape, { Point } from \"./shape\";\n\nexport default class Clip {\n  image: HTMLImageElement;\n  shape: Shape;\n  offset: Point;\n\n  constructor(image: HTMLImageElement, shape: Shape, offset: Point) {\n    this.image = image;\n    this.shape = shape;\n    this.offset = offset;\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.save();\n    this.shape.createPath(ctx);\n    ctx.clip();\n    ctx.drawImage(this.image, -this.offset.x, -this.offset.y);\n    ctx.restore();\n  }\n}\n","import Clip from \"./clip\";\nimport { Point } from \"./shape\";\nimport { SlotName } from \"./slots\";\n\nconst RECYCLED_TEST_POINT = { x: 0, y: 0 };\n\nexport default class PuzzlePiece {\n  slot: SlotName;\n  clip: Clip;\n  offset: Point;\n  rotation: number;\n\n  constructor(slot: SlotName, clip: Clip, offset: Point, rotation: number) {\n    this.slot = slot;\n    this.clip = clip;\n    this.offset = offset;\n    this.rotation = rotation;\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.save();\n    ctx.translate(this.offset.x, this.offset.y);\n    ctx.rotate(this.rotation);\n    this.clip.draw(ctx);\n    ctx.restore();\n  }\n\n  drawHovered(ctx: CanvasRenderingContext2D) {\n    ctx.save();\n    ctx.translate(this.offset.x, this.offset.y);\n    ctx.rotate(this.rotation);\n    this.clip.shape.createPath(ctx);\n    ctx.fillStyle = \"#fff4\";\n    ctx.fill();\n    ctx.restore();\n  }\n\n  isPointInside(point: Point): boolean {\n    RECYCLED_TEST_POINT.x = point.x - this.offset.x;\n    RECYCLED_TEST_POINT.y = point.y - this.offset.y;\n\n    return this.clip.shape.isPointInside(RECYCLED_TEST_POINT);\n  }\n}\n","export type Point = { x: number; y: number };\n\nexport default class Shape {\n  points: Point[];\n  width: number;\n  height: number;\n\n  constructor(points: Point[]) {\n    this.points = points;\n\n    let minX = 0.0;\n    let maxX = 0.0;\n    let minY = 0.0;\n    let maxY = 0.0;\n\n    for (const point of points) {\n      minX = Math.min(point.x, minX);\n      maxX = Math.max(point.x, maxX);\n      minY = Math.min(point.y, minY);\n      maxY = Math.max(point.y, maxY);\n    }\n\n    this.width = maxX - minX;\n    this.height = maxY - minY;\n  }\n\n  scale(scale: number) {\n    for (const point of this.points) {\n      point.x *= scale;\n      point.y *= scale;\n    }\n\n    this.width *= scale;\n    this.height *= scale;\n  }\n\n  createPath(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n\n    const firstPoint = this.points[0];\n    ctx.moveTo(firstPoint.x, firstPoint.y);\n\n    for (let i = 1; i < this.points.length; i++) {\n      const point = this.points[i];\n      ctx.lineTo(point.x, point.y);\n    }\n\n    ctx.closePath();\n  }\n\n  isPointInside(testPoint: Point): boolean {\n    let intersectionCount = 0;\n\n    let lastPoint = this.points[this.points.length - 1];\n\n    for (const point of this.points) {\n      const rise = point.y - lastPoint.y;\n      const run = point.x - lastPoint.x;\n      const slope = rise / run;\n      const b = point.y - slope * point.x;\n\n      const y = testPoint.x * slope + b;\n\n      const xIsLess = point.x <= testPoint.x || lastPoint.x <= testPoint.x;\n      const xIsGreater = point.x >= testPoint.x || lastPoint.x >= testPoint.x;\n      const xIsWithin = xIsLess && xIsGreater;\n\n      if (y >= testPoint.y && xIsWithin) {\n        intersectionCount += 1;\n      }\n\n      lastPoint = point;\n    }\n\n    return intersectionCount % 2 == 1;\n  }\n}\n\nexport class Hexagon extends Shape {\n  constructor(scale: number) {\n    const deg60 = (Math.PI * 60) / 180;\n    const offsetX = Math.sin(deg60) * 0.5;\n\n    super([\n      { x: 0, y: -0.5 },\n      { x: offsetX, y: -0.25 },\n      { x: offsetX, y: 0.25 },\n      { x: 0, y: 0.5 },\n      { x: -offsetX, y: 0.25 },\n      { x: -offsetX, y: -0.25 },\n    ]);\n\n    this.scale(scale);\n  }\n}\n","import PuzzlePiece from \"./puzzle-piece\";\n\nexport type SlotName =\n  | \"CENTER\"\n  | \"LEFT\"\n  | \"RIGHT\"\n  | \"TOP_LEFT\"\n  | \"TOP_RIGHT\"\n  | \"BOTTOM_LEFT\"\n  | \"BOTTOM_RIGHT\";\n\n// all specified in counter clockwise order for easy rotation later\nexport const TOP_SLOT_GROUP: SlotName[] = [\"CENTER\", \"TOP_LEFT\", \"TOP_RIGHT\"];\nexport const LEFT_SLOT_GROUP: SlotName[] = [\"CENTER\", \"BOTTOM_LEFT\", \"LEFT\"];\nexport const RIGHT_SLOT_GROUP: SlotName[] = [\"CENTER\", \"RIGHT\", \"BOTTOM_RIGHT\"];\nexport const ALL_GROUPS: SlotName[][] = [\n  TOP_SLOT_GROUP,\n  LEFT_SLOT_GROUP,\n  RIGHT_SLOT_GROUP,\n];\n\nexport function resolveSlotGroup(slot: SlotName): SlotName[] {\n  if (TOP_SLOT_GROUP.includes(slot)) {\n    return TOP_SLOT_GROUP;\n  }\n  if (LEFT_SLOT_GROUP.includes(slot)) {\n    return LEFT_SLOT_GROUP;\n  }\n  return RIGHT_SLOT_GROUP;\n}\n\nexport function mapSlotGroup(\n  slotGroup: SlotName[],\n  pieces: PuzzlePiece[]\n): PuzzlePiece[] {\n  return slotGroup.map((slot) => pieces.find((piece) => piece.slot == slot)!);\n}\n\nexport function rotateGroup(slotGroup: SlotName[], pieces: PuzzlePiece[]) {\n  const groupPieces = mapSlotGroup(slotGroup, pieces);\n\n  const lastPiece = groupPieces[groupPieces.length - 1];\n  let previousSlot = lastPiece.slot;\n  let previousOffset = lastPiece.offset;\n\n  for (const piece of groupPieces) {\n    const currentSlot = piece.slot;\n    const currentOffset = piece.offset;\n\n    piece.slot = previousSlot;\n    piece.offset = previousOffset;\n    piece.rotation -= (Math.PI * 2) / 3;\n\n    previousSlot = currentSlot;\n    previousOffset = currentOffset;\n  }\n}\n","import Clip from \"./clip\";\nimport PuzzlePiece from \"./puzzle-piece\";\nimport { Hexagon, Point } from \"./shape\";\nimport {\n  ALL_GROUPS as ALL_SLOT_GROUPS,\n  mapSlotGroup,\n  resolveSlotGroup,\n  rotateGroup,\n} from \"./slots\";\n\nconst BASE_IMAGE = document.getElementById(\"base-image\") as HTMLImageElement;\nconst CLIP_SHAPE = new Hexagon(170);\n\nexport default class Game {\n  pieces: PuzzlePiece[];\n  mouse: Point;\n  clicked: boolean;\n  backgroundOffset: Point;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this.mouse = { x: 0, y: 0 };\n    this.clicked = false;\n\n    canvas.onmousedown = () => {\n      this.clicked = true;\n    };\n\n    canvas.onmousemove = (event) => {\n      const boundingRect = canvas.getBoundingClientRect();\n      const xScale = canvas.width / boundingRect.width;\n      const yScale = canvas.height / boundingRect.height;\n\n      this.mouse.x = (event.x - boundingRect.left) * xScale;\n      this.mouse.y = (event.y - boundingRect.top) * yScale;\n    };\n\n    this.pieces = [\n      // top row\n      new PuzzlePiece(\n        \"TOP_LEFT\",\n        new Clip(BASE_IMAGE, CLIP_SHAPE, { x: 440, y: 100 }),\n        { x: CLIP_SHAPE.width, y: CLIP_SHAPE.height * 0.5 },\n        0\n      ),\n      new PuzzlePiece(\n        \"TOP_RIGHT\",\n        new Clip(BASE_IMAGE, CLIP_SHAPE, { x: 586, y: 100 }),\n        { x: CLIP_SHAPE.width * 2, y: CLIP_SHAPE.height * 0.5 },\n        0\n      ),\n      // middle row\n      new PuzzlePiece(\n        \"LEFT\",\n        new Clip(BASE_IMAGE, CLIP_SHAPE, { x: 366, y: 227 }),\n        { x: CLIP_SHAPE.width * 0.5, y: CLIP_SHAPE.height * 1.25 },\n        0\n      ),\n      new PuzzlePiece(\n        \"CENTER\",\n        new Clip(BASE_IMAGE, CLIP_SHAPE, { x: 513, y: 227 }),\n        { x: CLIP_SHAPE.width * 1.5, y: CLIP_SHAPE.height * 1.25 },\n        0\n      ),\n      new PuzzlePiece(\n        \"RIGHT\",\n        new Clip(BASE_IMAGE, CLIP_SHAPE, { x: 660, y: 227 }),\n        { x: CLIP_SHAPE.width * 2.5, y: CLIP_SHAPE.height * 1.25 },\n        0\n      ),\n      // bottom row\n      new PuzzlePiece(\n        \"BOTTOM_LEFT\",\n        new Clip(BASE_IMAGE, CLIP_SHAPE, { x: 439, y: 354 }),\n        { x: CLIP_SHAPE.width, y: CLIP_SHAPE.height * 2 },\n        0\n      ),\n      new PuzzlePiece(\n        \"BOTTOM_RIGHT\",\n        new Clip(BASE_IMAGE, CLIP_SHAPE, { x: 586, y: 353 }),\n        { x: CLIP_SHAPE.width * 2, y: CLIP_SHAPE.height * 2 },\n        0\n      ),\n    ];\n\n    // center the pieces\n    const puzzle_width = CLIP_SHAPE.width * 3;\n    const puzzle_height = CLIP_SHAPE.height * 2.5;\n\n    const padding_x = (canvas.width - puzzle_width) / 2;\n    const padding_y = (canvas.height - puzzle_height) / 2;\n\n    for (const piece of this.pieces) {\n      piece.offset.x += padding_x;\n      piece.offset.y += padding_y;\n    }\n\n    // setup background offset\n    const firstPiece = this.pieces[0];\n    this.backgroundOffset = {\n      x: firstPiece.offset.x - firstPiece.clip.offset.x,\n      y: firstPiece.offset.y - firstPiece.clip.offset.y,\n    };\n  }\n\n  shuffle(amount: number) {\n    for (let i = 0; i < amount; i++) {\n      const groupIndex = Math.floor(Math.random() * ALL_SLOT_GROUPS.length);\n      const group = ALL_SLOT_GROUPS[groupIndex];\n      rotateGroup(group, this.pieces);\n    }\n  }\n\n  update(delta: number) {\n    if (this.clicked) {\n      this.clicked = false;\n    } else {\n      return;\n    }\n\n    const clickedPiece = this.pieces.find((piece) =>\n      piece.isPointInside(this.mouse)\n    );\n\n    if (clickedPiece && clickedPiece.slot != \"CENTER\") {\n      const slotGroup = resolveSlotGroup(clickedPiece.slot);\n      rotateGroup(slotGroup, this.pieces);\n    }\n  }\n\n  render(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n    // ctx.fillStyle = \"#513F2B\";\n    // ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // draw background\n    ctx.drawImage(BASE_IMAGE, this.backgroundOffset.x, this.backgroundOffset.y);\n\n    // draw pieces\n    for (const piece of this.pieces) {\n      piece.draw(ctx);\n    }\n\n    // draw hovered slot group\n    const hoveredPiece = this.pieces.find((piece) =>\n      piece.isPointInside(this.mouse)\n    );\n\n    if (hoveredPiece && hoveredPiece.slot != \"CENTER\") {\n      const slotGroup = resolveSlotGroup(hoveredPiece.slot);\n      const groupPieces = mapSlotGroup(slotGroup, this.pieces);\n\n      for (const piece of groupPieces) {\n        piece.drawHovered(ctx);\n      }\n    }\n  }\n}\n","import Game from \"./game\";\n\nconst canvas = document.querySelector(\"canvas\")!;\nconst ctx = canvas.getContext(\"2d\")!;\nconst game = new Game(canvas);\n\nlet previousTime;\n\nfunction gameLoop(time: number) {\n  if (previousTime == undefined) {\n    previousTime = time;\n    requestAnimationFrame(gameLoop);\n    return;\n  }\n\n  const delta = (time - previousTime) / 1000;\n  previousTime = time;\n\n  game.update(delta);\n  game.render(canvas, ctx);\n\n  requestAnimationFrame(gameLoop);\n}\n\nwindow.addEventListener(\"load\", function () {\n  gameLoop(0);\n});\n\ndocument.getElementById(\"shuffle-button\")!.onclick = function () {\n  const shuffleInput = document.getElementById(\n    \"shuffle-input\"\n  ) as HTMLInputElement;\n\n  game.shuffle(parseInt(shuffleInput.value));\n};\n"],"names":["$3c4247b5a274307d$export$2e2bcd8739ae039","constructor","image","shape","offset","this","draw","ctx","save","createPath","clip","drawImage","x","y","restore","$5bfe4b6eb771a6c5$var$RECYCLED_TEST_POINT","$5bfe4b6eb771a6c5$export$2e2bcd8739ae039","slot","rotation","translate","rotate","drawHovered","fillStyle","fill","isPointInside","point","$907015fa4454756c$export$2e2bcd8739ae039","points","minX","maxX","minY","maxY","Math","min","max","width","height","scale","beginPath","firstPoint","moveTo","i","length","lineTo","closePath","testPoint","intersectionCount","lastPoint","slope","b","xIsLess","xIsGreater","xIsWithin","$69b737070667de0d$export$322717858ca16e2b","$69b737070667de0d$export$ecbdb3bba27cde5c","$69b737070667de0d$export$c0be88fb78df2cd3","$69b737070667de0d$export$50223ad7f5125750","$69b737070667de0d$export$b65da291aa3120c5","includes","$69b737070667de0d$export$7c4922b86192d59b","slotGroup","pieces","map","find","piece","$69b737070667de0d$export$da2981edf3c62b8b","groupPieces","lastPiece","previousSlot","previousOffset","currentSlot","currentOffset","PI","$e46db5192eb49d53$var$BASE_IMAGE","document","getElementById","$e46db5192eb49d53$var$CLIP_SHAPE","deg60","offsetX","sin","super","$b4e14b6b8da86996$var$canvas","querySelector","$b4e14b6b8da86996$var$ctx","getContext","$b4e14b6b8da86996$var$game","canvas","mouse","clicked","onmousedown","onmousemove","event","boundingRect","getBoundingClientRect","xScale","yScale","left","top","puzzle_width","puzzle_height","padding_x","padding_y","firstPiece","backgroundOffset","shuffle","amount","groupIndex","floor","random","update","delta","clickedPiece","render","hoveredPiece","$b4e14b6b8da86996$var$previousTime","$b4e14b6b8da86996$var$gameLoop","time","undefined","requestAnimationFrame","window","addEventListener","onclick","shuffleInput","parseInt","value"],"version":3,"file":"index.c7153faf.js.map"}